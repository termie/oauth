<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<rfc category="std" ipr="trust200902" docName="draft-hammer-http-token-auth-00">

  <?rfc strict="yes" ?>
  <?rfc toc="yes" ?>
  <?rfc tocdepth="3" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes" ?>
  <?rfc compact="yes" ?>
  <?rfc subcompact="no" ?>

  <front>
    
    <title abbrev="Token Authentication">HTTP Authentication: Token Access Authentication</title>

    <author initials="E" surname="Hammer-Lahav" fullname="Eran Hammer-Lahav">
      <organization>
        Yahoo!
      </organization>
      <address>
        <email>eran@hueniverse.com</email>
        <uri>http://hueniverse.com</uri>
      </address>
    </author>

    <date year="2009"/>

    <abstract>
      <t>
        This document specifies the HTTP Token Access Authentication scheme.
      </t>
    </abstract>

  </front>
  <middle>

    <section title="Introduction">
      <t>
        [[ This draft is submitted for the consideration of the OAuth Working Group to be adoped as
        an official working group item per its current charter. Please discuss this draft on the
        <eref target="https://www.ietf.org/mailman/listinfo/oauth">oauth@ietf.org</eref> mailing
        list. ]]
      </t>
      <t>
        With the growing use of distributed web services and cloud computing, clients need to allow
        other parties access to the resources they control. When granting access, clients should
        not be required to share their credentials (typically a username and passowrd), and should
        have the ability to restrict access to a limited subset of the resources they control or
        the access methods supported by these resources. These goals require new classes of
        authentication credentials.
      </t>
      <t>
        The HTTP Basic and Digest Access authentication schemes defined by <xref target="RFC2617" />,
        enable clients to make authenticated HTTP requests by using a username (or userid) and
        a password. In most cases, the client uses a single set of credentials to access all the
        resources it controls which are hosted by the server.
      </t>
      <t>
        While the Basic and Digest schemes can be used to send credentials other than a username
        and password, their wide deployment and well-established behavior in user-agents preclude
        them from being used with other classes of credentials. Extending these schemes to support
        new classes would require impractical changes to the existing deployment base.
      </t>
      <t>
        The Token Access Authentication scheme provides a method for making authenticated HTTP
        requests using a token - an identifier used to denote an access grant with specific scope,
        duration, or other limitations. Tokens are typically issued by the server, and may include
        a shared secret known only to the authorized client.
      </t>
      <t>
        The token scheme support an extensible set of credential classes, by enabling the server to
        declare the classes it supports. It also supports an extensible set of authentication
        coverage - the elements of the HTTP request (e.g. request URI, entity-body) included in the
        authentication process.
      </t>
      <t>
        This specification defines four token classes to support the most common use cases and
        describes their security properties. The methods through which clients obtain tokens are
        beyond the scope of this specification. The OAuth protocol
        <xref target="I-D.ietf-oauth-web-delegation" /> defines one such set of methods for
        obtaining token credentials.
      </t>

      <section title="Terminology">
        <t>
          <list style="hanging" hangIndent="6">
            <t hangText="client">
              <vspace />
              An HTTP client (per <xref target="RFC2616" />) capable of making
              <xref target="requests">Token-authenticated requests</xref>.
            </t>
            <t hangText="server">
              <vspace />
              An HTTP server (per <xref target="RFC2616" />) capable of accepting
              <xref target="requests">Token-authenticated requests</xref>.
            </t>
            <t hangText="protected resource">
              <vspace />
              An access-restricted resource (per <xref target="RFC2616" />) hosted by the server
              and accessible by making a <xref target="requests">Token-authenticated request</xref>.
            </t>
            <t hangText="token credentials">
              A set of token (unique identifier), an OPTIONAL matching shared secret (symmetric
              or asymmetric), class, and other attributes, used by the client to make authenticated
              requests.
            </t>
          </list>
        </t>
      </section>

      <section title="Example">
        <figure>
          <preamble>
            The following HTTP request:
          </preamble>
          <artwork xml:space="preserve"><![CDATA[
  GET /resource/1 HTTP/1.1
  Host: example.com
]]>
          </artwork>
        </figure>
        <figure>
          <preamble>
            returns the following authentication challange:
          </preamble>
          <artwork xml:space="preserve"><![CDATA[
  HTTP/1.1 401 Unauthorized
  WWW-Authenticate: Token realm="generic",
                          classes="hmac-sha-1 hmac-sha-256",
                          timestamp="137131190"
]]>
          </artwork>
        </figure>
        <t>
          This means the server is expecting a token issued for the
          <spanx style="verb">generic</spanx> realm of either class
          <spanx style="verb">hmac-sha-1</spanx> or <spanx style="verb">hmac-sha-256</spanx>. It
          also provides it current time to assist the client in synchronizing its clock with the
          server for the purpose of producing a unique nonce value.
        </t>
        <figure>
          <preamble>
            The client attempts the HTTP request again, this time using a class
            <spanx style="verb">hmac-sha-1</spanx> token issued by the server earlier to
            authenticate:
          </preamble>
          <artwork xml:space="preserve"><![CDATA[
  GET /resource/1 HTTP/1.1
  Host: example.com
  Authorization: Token realm="generic",
                       class="hmac-sha-1",
                       token="h480djs93hd8",
                       timestamp="137131200",
                       nonce="dj83hs9s",
                       auth="djosJKDKJSD8743243/jdk33klY="
]]>
          </artwork>
          <postamble>
            to which the server respond with the requested resource representation after validating
            the request.
          </postamble>
        </figure>
      </section>

      <section title="Notational Conventions">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
          "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in
          <xref target="RFC2119" />.
        </t>
        <t>
          This document uses the Augmented Backus-Naur Form (ABNF) notation of
          <xref target="I-D.ietf-httpbis-p1-messaging" />. Additionally, the following rules are
          included from <xref target="RFC2617" />: realm, auth-param.
        </t>
      </section>

    </section>

    <section title="Making Requests" anchor="requests">
      <t>
        The clients makes authenticated requests by calculating the value of a set of attributes
        and adding them to the HTTP request using the <xref target="authz">Authorization header field</xref>.
        Authenticated request can be sent either directly (without first receiving a challenge), or
        in response to an authentication challenge.
      </t>
      <t>
        To make an authenticated request, the client obtains information about the token classes
        and authentication coverage supported by the server. This information is provided by the
        server via the <xref target="authn">WWW-Authenticate header field</xref>. The client SHOULD
        only send an authenticated request to server without first receiving a challenge when it
        has prior knowledge of the token classes and other attributes supported by server.
      </t>
      <t>
        The client chooses the token class and authentication coverage.
      </t>

      <t>
        The protocol parameters are added to the request.
      </t>
      <t>
        The client calculates and assigns the value of the <spanx style="verb">oauth_signature</spanx>
        parameter as described in <xref target="methods" /> and adds the parameter to the
        request using the same method used in the previous step.
      </t>
      <t>
        The client sends the authenticated HTTP request to the server.
      </t>
      <figure>
        <preamble>
          For example, to make the following HTTP request authenticated:
        </preamble>
        <artwork xml:space="preserve"><![CDATA[
  GET /request?b5=%3D%253D&a3=a&c%40=&a2=r%20b HTTP/1.1
  Host: example.com
  Content-Type: application/x-www-form-urlencoded

  c2&a3=2+q
]]>
        </artwork>
      </figure>
      <figure>
        <preamble>
          The client assigns values to the following protocol parameters using its client
          credentials, token credentials, the current timestamp, a uniquely generated nonce, and
          indicates it will use the <spanx style="verb">HMAC-SHA1</spanx> signature method:
        </preamble>
        <artwork xml:space="preserve"><![CDATA[
  oauth_consumer_key:     9djdj82h48djs9d2
  oauth_token:            kkk9d7dh3k39sjv7
  oauth_signature_method: HMAC-SHA1
  oauth_timestamp:        137131201
  oauth_nonce:            7d8f3e4a
]]>
        </artwork>
      </figure>
      <figure>
        <preamble>
          The client adds the protocol parameter to the request using the OAuth HTTP
          Authorization header:
        </preamble>
        <artwork xml:space="preserve"><![CDATA[
  Authorization: OAuth realm="http://example.com/",
                 oauth_consumer_key="9djdj82h48djs9d2",
                 oauth_token="kkk9d7dh3k39sjv7",
                 oauth_signature_method="HMAC-SHA1",
                 oauth_timestamp="137131201",
                 oauth_nonce="7d8f3e4a"
]]>
        </artwork>
      </figure>
      <figure>
        <preamble>
          Then calculates the value of the <spanx style="verb">oauth_signature</spanx> parameter,
          adds it to the request, and sends the HTTP request to the server:
        </preamble>
        <artwork xml:space="preserve"><![CDATA[
  GET /request?b5=%3D%253D&a3=a&c%40=&a2=r%20b HTTP/1.1
  Host: example.com
  Content-Type: application/x-www-form-urlencoded
  Authorization: OAuth realm="http://example.com/",
                 oauth_consumer_key="9djdj82h48djs9d2",
                 oauth_token="kkk9d7dh3k39sjv7",
                 oauth_signature_method="HMAC-SHA1",
                 oauth_timestamp="137131201",
                 oauth_nonce="7d8f3e4a",
                 oauth_signature="djosJKDKJSD8743243%2Fjdk33klY%3D"

  c2&a3=2+q
]]>
        </artwork>
      </figure>
    </section>

    <section title="Verifying Requests" anchor="verify_request">
      <t>
        Servers receiving an authenticated request MUST validate it by:

        <list style="symbols">
          <t>
            Recalculate the request signature independently as described in
            <xref target="methods" /> and compare it to the value received from the client via
            the <spanx style="verb">oauth_signature</spanx> parameter.
          </t>
          <t>
            If using the <spanx style="verb">HMAC-SHA1</spanx> or
            <spanx style="verb">RSA-SHA1</spanx> signature methods, ensure that the combination
            of nonce/timestamp/token (if present) received from the client has not been used
            before in a previous request (the server MAY reject requests with stale timestamps).
          </t>
          <t>
            If a token is present, verify the scope and status of the client authorization as
            represented by the token (the server MAY choose to restrict token usage to the client
            to which it was issued).
          </t>
        </list>
      </t>
      <t>
        If the request fails verification, the server SHOULD respond with the appropriate HTTP
        response status code. The server MAY include further details about why the request was
        rejected in the response body.
      </t>
      <t>
        The server SHOULD return a 400 (bad request) status code
        when receiving a request with unsupported parameters, unsupported signature method,
        missing parameters, or duplicated protocol parameters. The server SHOULD return a 401
        (unauthorized) status code when receiving a request with invalid client credentials,
        invalid or expired token, invalid signature, or invalid or used nonce.
      </t>
    </section>

    <section title="The WWW-Authenticate Response Header" anchor="authn_header">
      <t>
        A server receiving a request for a protected resource without a valid
        <xref target="authz_header">Authorization header field</xref> MUST respond with a 401
        status code (Unauthorized), and includes at least one
        <spanx style="verb">WWW-Authenticate</spanx> header field including a token scheme
        challenge.
      </t>
      <t>
        The <spanx style="verb">WWW-Authenticate</spanx> header field uses the framework defined by
        <xref target="RFC2617" /> as follows:
      </t>
      <figure>
        <artwork xml:space="preserve"><![CDATA[
 challenge       = "Token" RWS token-challenge
   
 token-challenge = realm
                   CS class-list
                   [ CS coverage-list ]
                   [ CS timestamp ]
   
 class-list      = "class" "=" <"> 1#class-name <">
 class-name      = "hmac-sha-1" /
                   "hmac-sha-256" /
                   "rsassa-pkcs1-v1.5-sha-256" /
                   "bearer-opaque" /
                   token

 coverage-list   = "coverage" "=" <"> 1#coverage-name <">
 coverage-name   = "base" /
                   "base+body-sha-256" /
                   token

 timestamp       = "timestamp" "=" <"> 1*DIGIT <">
 
 CS              = OWF "," OWF
]]>
        </artwork>
      </figure>

      <section title="The 'realm' attribute">
        <t>
          [[ TBD ]]
        </t>
      </section>

      <section title="The 'classes' attribute">
        <t>
          The list of token classes names supported by the server, provided as a space-delimited
          list. Token classes are defined in <xref target="classes" />
        </t>
      </section>

      <section title="The 'timestamp' attribute">
        <t>
          The timestmap attribute is used by the server to publish its current time, enabling
          clients to synchronize their close with the server. The timestamp value is the current
          time expressed in the number of seconds since January 1, 1970 00:00:00 GMT, and MUST be a
          positive integer.
        </t>
        <t>
          Signature-based and hash-based authentication methods use timestamps in combination with
          unique nonce values to protect against replay attacks when used over an unsecure channel.
          To avoid the need to retain an infinite number of nonce values for future checks, servers
          MAY choose to restrict the time period after which a request with an old timestamp is
          rejected. Servers applying such a restriction SHOULD provide their current time to the
          client either in every challenge or when a request fails due to a timestamp outside the
          allowed window.
        </t>
      </section>

    </section>

    <section title="The Authorization Request Header" anchor="authz_header">
      <t>
        A client making a request for a protected resource either directly, or in retrying a
        request after receiving a 401 status code (Unauthorized) with a token challenge, MUST
        include at least one <spanx style="verb">Authorization</spanx> header field including
        token scheme credentials.
      </t>
      <t>
        The <spanx style="verb">Authorization</spanx> header field uses the framework defined by
        <xref target="RFC2617" /> as follows:
      </t>
      <figure>
        <artwork xml:space="preserve"><![CDATA[
 credentials    = "Token" RWS token-response
   
 token-response = realm
                  CS token-id
                  CS class
                  [ CS coverage ]
                  [ CS nonce ]
                  [ CS timestamp ]
                  [ CS auth ]

 token-id         = "token" "=" <"> token <">
 class            = "class" "=" <"> class-name <">
 coverage         = "coverage" "=" <"> coverage-name <">
 nonce            = "token" "=" <"> token <">
 auth             = "auth" "=" <"> token <">
]]>
        </artwork>
      </figure>

      <section title="The 'realm' attribute">
        <t>
          [[ TBD ]]
        </t>
      </section>

      <section title="The 'class' attribute">
        <t>
          The name of the token class used by the client to make the request as defined by
          <xref target="classes" />
        </t>
      </section>

      <section title="The 'token' attribute">
        <t>
          The value used to identify the set of token credentials used by the client to
          authenticate. The token identifier can be an opaque string or use a well-defined internal
          structure, which is determined by the token class.
        </t>
      </section>

      <section title="The 'nonce' attribute">
        <t>
          A nonce is a random string, uniquely generated by the client to allow the server to
          verify that a request has never been made before and helps prevent replay attacks when
          requests are made over a non-secure channel. The nonce value MUST be unique across all
          requests with the same timestamp and token combinations.
        </t>
      </section>

      <section title="The 'timestamp' attribute">
        <t>
          The timestamp value is the current time expressed in the number of seconds since
          January 1, 1970 00:00:00 GMT, and MUST be a positive integer.
        </t>
      </section>

      <section title="The 'auth' attribute">
        <t>

        </t>
      </section>

    </section>

    <section title="The Authentication-Error Response Header" anchor="error_header">
      <t>
        A server receiving a request for a protected resource with an invalid
        <xref target="authz_header">Authorization header field</xref> MAY includes the
        <spanx style="verb">Authentication-Error</spanx> header field providing the client with
        information to help it successfully authenticate with the server.
      </t>
      <t>
        The <spanx style="verb">Authentication-Error</spanx> header field is defined as follows:
      </t>
      <figure>
        <artwork xml:space="preserve"><![CDATA[
 Authentication-Error   = "Authentication-Error" ":" OWS #1error-param
                      
 error-param            = error-code /
                          error-info /
                          error-message /
                          auth-param

 error-code      = "error-code"    "=" <"> token <">
 error-info      = "error-info"    "=" <"> token <">
 error-message   = "error-message" "=" quoted-string
  ]]>
        </artwork>
      </figure>
      
      <section title="The 'error-code' attribute">
        <t>

        </t>
      </section>

      <section title="The 'error-info' attribute">
        <t>

        </t>
      </section>

      <section title="The 'error-message' attribute">
        <t>

        </t>
      </section>

    </section>

    <section title="Token Classes" anchor="classes">
      <t>
				In order for the server to
        verify the authenticity of the request and prevent unauthorized access, the client needs
        to prove that it is the rightful owner of the credentials. This is accomplished using the
        shared-secret (or RSA key) part of each set of credentials.
      </t>
      <t>
        OAuth provides three methods for the client to prove its rightful ownership of the
        credentials: <spanx style="verb">HMAC-SHA1</spanx>, <spanx style="verb">RSA-SHA1</spanx>,
        and <spanx style="verb">PLAINTEXT</spanx>. These methods are generally referred to as
        signature methods, even though <spanx style="verb">PLAINTEXT</spanx> does not involve a
        signature. In addition, <spanx style="verb">RSA-SHA1</spanx> utilizes an RSA key instead
        of the shared-secrets associated with the client credentials.
      </t>
      <t>
        The client declares which signature method is used via the
        <spanx style="verb">oauth_signature_method</spanx> parameter. It then generates a signature
        (or a string of an equivalent value), and includes it in the
        <spanx style="verb">oauth_signature</spanx> parameter. The server verifies the signature
        as specified for each method.
      </t>
      <t>
        The signature process does not change the request or its parameters, with the exception of
        the <spanx style="verb">oauth_signature</spanx> parameter.
      </t>

      <section title="Plain">
        <t>
          The <spanx style="verb">PLAINTEXT</spanx> method does not employ a signature algorithm
          and does not provide any security on its own as it transmits secrets in the clear. It
          SHOULD only be used with a transport-layer mechanism such as TLS or SSL as explained in
          <xref target="plain_ssl" />. It does not utilize the signature base string nor the
          <spanx style="verb">oauth_timestamp</spanx> and <spanx style="verb">oauth_nonce</spanx>
          parameters.
        </t>
        <t>
          The <spanx style="verb">oauth_signature</spanx> protocol parameter is set to the
          concatenated value of:

          <list style="numbers">
            <t>
              The client shared-secret, after being <xref target="encoding">encoded</xref>.
            </t>
            <t>
              An <spanx style="verb">&amp;</spanx> character (ASCII code 38), which MUST be
              included even when either secret is empty.
            </t>
            <t>
              The token shared-secret, after being <xref target="encoding">encoded</xref>.
            </t>
          </list>
        </t>
      </section>

      <section title="HMAC">
        <t>
          The <spanx style="verb">HMAC-SHA1</spanx> signature method uses the HMAC-SHA1 signature
          algorithm as defined in <xref target="RFC2104" />:

          <figure>
            <artwork xml:space="preserve"><![CDATA[
  digest = HMAC-SHA1 (key, text)
]]>
            </artwork>
          </figure>
        </t>
        <t>
          The HMAC-SHA1 function variables are used in following way:

          <list style="hanging" hangIndent="6">
            <t hangText="text">
              <vspace />
              is set to the value of the signature base string from <xref target="base_string" />.
            </t>
            <t hangText="key">
              <vspace />
              is set to the concatenated values of:

              <list style="numbers">
                <t>
                  The client shared-secret, after being <xref target="encoding">encoded</xref>.
                </t>
                <t>
                  An <spanx style="verb">&amp;</spanx> character (ASCII code 38), which MUST be
                  included even when either secret is empty.
                </t>
                <t>
                  The token shared-secret, after being <xref target="encoding">encoded</xref>.
                </t>
              </list>
            </t>
            <t hangText="digest">
              <vspace />
              is used to set the value of the <spanx style="verb">oauth_signature</spanx>
              protocol parameter, after the result octet string is base64-encoded per
              <xref target="RFC2045" /> section 6.8.
            </t>
          </list>
        </t>
      </section>

      <section title="RSA">
        <t>
          The <spanx style="verb">RSA-SHA1</spanx> signature method uses the RSASSA-PKCS1-v1_5
          signature algorithm as defined in <xref target="RFC3447" /> section 8.2 (also known as
          PKCS#1), using SHA-1 as the hash function for EMSA-PKCS1-v1_5. To use this method, the
          client MUST have established client credentials with the server which included its RSA
          public key (in a manner which is beyond the scope of this specification).
        </t>
        <t>
          The signature base string is signed using the client's RSA private key per
          <xref target="RFC3447" /> section 8.2.1:

          <figure>
            <artwork xml:space="preserve"><![CDATA[
  S = RSASSA-PKCS1-V1_5-SIGN (K, M)
]]>
              </artwork>
          </figure>

          Where:

          <list style="hanging" hangIndent="6">
            <t hangText="K">
              <vspace />
              is set to the client's RSA private key,
            </t>
            <t hangText="M">
              <vspace />
              is set to the value of the signature base string from <xref target="base_string" />, and
            </t>
            <t hangText="S">
              <vspace />
              is the result signature used to set the value of the <spanx style="verb">oauth_signature</spanx>
              protocol parameter, after the result octet string is base64-encoded per <xref target="RFC2045" />
              section 6.8.
            </t>
          </list>
        </t>
        <t>
          The server verifies the signature per <xref target="RFC3447" /> section 8.2.2:

          <figure>
            <artwork xml:space="preserve"><![CDATA[
  RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)
]]>
              </artwork>
          </figure>

          Where:

          <list style="hanging" hangIndent="6">
            <t hangText="(n, e)">
              <vspace />
              is set to the client's RSA public key,
            </t>
            <t hangText="M">
              <vspace />
              is set to the value of the signature base string from <xref target="base_string" />, and
            </t>
            <t hangText="S">
              <vspace />
              is set to the octet string value of the <spanx style="verb">oauth_signature</spanx>
              protocol parameter received from the client.
            </t>
          </list>
        </t>
      </section>

    </section>
    
    <section title="Signature Base String">
      <t>
        The signature base string is a consistent, reproducible concatenation of several
        of the HTTP request elements into a single string. The string is used as an input to
        the <spanx style="verb">HMAC-SHA1</spanx> and <spanx style="verb">RSA-SHA1</spanx>
        signature methods.
      </t>
      <t>
        The signature base string includes the following components of the HTTP request:

        <list style="symbols">
          <t>
            The HTTP request method (e.g. <spanx style="verb">GET</spanx>,
            <spanx style="verb">POST</spanx>, etc.).
          </t>
          <t>
            The authority as declared by the HTTP <spanx style="verb">Host</spanx> request
            header.
          </t>
          <t>
            The path and query components of the request resource URI.
          </t>
          <t>
            The protocol parameters excluding the
            <spanx style="verb">oauth_signature</spanx>.
          </t>
          <t>
            Parameters included in the request entity-body if they comply with the strict
            restrictions defined in <xref target="collect_param" />.
          </t>
        </list>
      </t>
      <t>
        The signature base string does not cover the entire HTTP request. Most notably, it
        does not include the entity-body in most requests, nor does it include most HTTP
        entity-headers. It is important to note that the server cannot verify the authenticity
        of the excluded request components without using additional protections such as SSL/TLS or
        other methods.
      </t>

      <section title="String Construction" anchor="base_string">
        <t>
          The signature base string is constructed by concatenating together, in order, the
          following HTTP request elements:

          <list style="numbers">
            <t>
              The HTTP request method in uppercase. For example: <spanx style="verb">HEAD</spanx>,
              <spanx style="verb">GET</spanx>, <spanx style="verb">POST</spanx>, etc. If the
              request uses a custom HTTP method, it MUST be <xref target="encoding">encoded</xref>.
            </t>
            <t>
              An <spanx style="verb">&amp;</spanx> character (ASCII code 38).
            </t>
            <t>
              The base string URI from <xref target="sig_uri" />, after being
              <xref target="encoding">encoded</xref>.
            </t>
            <t>
              An <spanx style="verb">&amp;</spanx> character (ASCII code 38).
            </t>
            <t>
              The request parameters as normalized in <xref target="sig_norm_param" />, after
              being <xref target="encoding">encoded</xref>.
            </t>
          </list>
        </t>
        <figure>
          <preamble>
            For example, the HTTP request:
          </preamble>
          <artwork xml:space="preserve"><![CDATA[
  GET /request?b5=%3D%253D&a3=a&c%40=&a2=r%20b HTTP/1.1
  Host: example.com
  Content-Type: application/x-www-form-urlencoded
  Authorization: OAuth realm="http://example.com/",
                 oauth_consumer_key="9djdj82h48djs9d2",
                 oauth_token="kkk9d7dh3k39sjv7",
                 oauth_signature_method="HMAC-SHA1",
                 oauth_timestamp="137131201",
                 oauth_nonce="7d8f3e4a",
                 oauth_signature="djosJKDKJSD8743243%2Fjdk33klY%3D"

  c2&a3=2+q
]]>
            </artwork>
        </figure>
        <figure>
          <preamble>
            Is represented by the following signature base string (line breaks are for display
            purposes only):
          </preamble>
          <artwork xml:space="preserve"><![CDATA[
  GET&http%3A%2F%2Fexample.com%2Frequest&a2%3Dr%2520b%26a3%3D2%2520q%
  26a3%3Da%26b5%3D%253D%25253D%26c%2540%3D%26c2%3D%26oauth_consumer_k
  ey%3D9djdj82h48djs9d2%26oauth_nonce%3D7d8f3e4a%26oauth_signature_me
  thod%3DHMAC-SHA1%26oauth_timestamp%3D137131201%26oauth_token%3Dkkk9
  d7dh3k39sjv7
]]>
            </artwork>
        </figure>
      </section>

      <section title="Base String URI" anchor="sig_uri">
        <t>
          The scheme, authority, and path of the request resource URI <xref target="RFC3986" />
          are included by constructing an <spanx style="verb">http</spanx> or
          <spanx style="verb">https</spanx> URI representing the request resource (without the
          query or fragment) as follows:

          <list style="numbers">
            <t>
              The scheme and host MUST be in lowercase.
            </t>
            <t>
              The host and port values MUST match the content of the HTTP request
              <spanx style="verb">Host</spanx> header.
            </t>
            <t>
              The port MUST be included if it is not the default port for the scheme, and MUST
              be excluded if it is the default. Specifically, the port MUST be excluded when
              making an HTTP request <xref target="RFC2616" /> to port 80 or when making an
              HTTPS request <xref target="RFC2818" /> to port 443. All other non-default port
              numbers MUST be included.
            </t>
          </list>
        </t>
        <figure>
          <preamble>
            For example, the HTTP request:
          </preamble>
          <artwork xml:space="preserve"><![CDATA[
  GET /r%20v/X?id=123 HTTP/1.1
  Host: EXAMPLE.COM:80
]]>
            </artwork>
          <postamble>
            is represented by the base string URI:
            <spanx style="verb">http://example.com/r%20v/X</spanx>.
          </postamble>
        </figure>
        <figure>
          <preamble>
            In another example, the HTTPS request:
          </preamble>
          <artwork xml:space="preserve"><![CDATA[
  GET /?q=1 HTTP/1.1
  Host: www.example.net:8080
]]>
            </artwork>
          <postamble>
            is represented by the base string URI:
            <spanx style="verb">https://www.example.net:8080/</spanx>.
          </postamble>
        </figure>
      </section>

      <section title="Request Parameters" anchor="collect_param">
        <t>
          In order to guarantee a consistent and reproducible representation of the request
          parameters, the parameters are collected and decoded to their original decoded form.
          They are then sorted and encoded in a particular manner which is often different from
          their original encoding scheme, and concatenated into a single string.
        </t>

        <section title="Parameter Sources">
          <t>
            The parameters from the following sources are collected into a single list of
            name/value pairs:

            <list style="symbols">
              <t>
                The query component of the HTTP request URI as defined by <xref target="RFC3986" />
                section 3.4. The query component is parsed into a list of name/value pairs by
                treating it as an <spanx style="verb">application/x-www-form-urlencoded</spanx>
                string, separating the names and values and decoding them as defined by
                <xref target="W3C.REC-html40-19980424" /> section 17.13.4.
              </t>
              <t>
                The OAuth HTTP Authorization header if present.
                The header's content is parsed into a list of name/value pairs excluding the
                <spanx style="verb">realm</spanx> parameter if present. The parameter values are
                decoded.
              </t>
              <t>
                The HTTP request entity-body, but only if all of the following conditions are met:

                <list style="symbols">
                  <t>
                    The entity-body is single-part.
                  </t>
                  <t>
                    The entity-body follows the encoding requirements of the
                    <spanx style="verb">application/x-www-form-urlencoded</spanx> content-type as
                    defined by <xref target="W3C.REC-html40-19980424" />.
                  </t>
                  <t>
                    The HTTP request entity-header includes the <spanx style="verb">Content-Type</spanx>
                    header set to <spanx style="verb">application/x-www-form-urlencoded</spanx>.
                  </t>
                </list>

                The entity-body is parsed into a list of decoded name/value pairs as described in
                <xref target="W3C.REC-html40-19980424" /> section 17.13.4.
              </t>
            </list>
          </t>
          <t>
            The <spanx style="verb">oauth_signature</spanx> parameter MUST be excluded from the
            signature base string if present. Parameters not explicitly included in the request
            MUST be excluded from the signature base string (e.g. the
            <spanx style="verb">oauth_version</spanx> parameter when omitted).
          </t>
          <figure>
            <preamble>
              For example, the HTTP request:
            </preamble>
            <artwork xml:space="preserve"><![CDATA[
    GET /request?b5=%3D%253D&a3=a&c%40=&a2=r%20b HTTP/1.1
    Host: example.com
    Content-Type: application/x-www-form-urlencoded
    Authorization: OAuth realm="http://example.com/",
                   oauth_consumer_key="9djdj82h48djs9d2",
                   oauth_token="kkk9d7dh3k39sjv7",
                   oauth_signature_method="HMAC-SHA1",
                   oauth_timestamp="137131201",
                   oauth_nonce="7d8f3e4a",
                   oauth_signature="djosJKDKJSD8743243%2Fjdk33klY%3D"

    c2&a3=2+q
]]>
              </artwork>
            <postamble>
              Contains the following (fully decoded) parameters used in the signature base
              sting:
            </postamble>
          </figure>
          <texttable>
            <ttcol align='center'>Name</ttcol>
            <ttcol align='center'>Value</ttcol>
            <c>b5</c>
            <c>=%3D</c>
            <c>a3</c>
            <c>a</c>
            <c>c@</c>
            <c></c>
            <c>a2</c>
            <c>r b</c>
            <c>oauth_consumer_key</c>
            <c>9djdj82h48djs9d2</c>
            <c>oauth_token</c>
            <c>kkk9d7dh3k39sjv7</c>
            <c>oauth_signature_method</c>
            <c>HMAC-SHA1</c>
            <c>oauth_timestamp</c>
            <c>137131201</c>
            <c>oauth_nonce</c>
            <c>7d8f3e4a</c>
            <c>c2</c>
            <c></c>
            <c>a3</c>
            <c>2 q</c>
          </texttable>
          <t>
            Note that the value of <spanx style="verb">b5</spanx> is <spanx style="verb">=%3D</spanx>
            and not <spanx style="verb">==</spanx>. Both <spanx style="verb">c@</spanx> and
            <spanx style="verb">c2</spanx> have empty values. While the encoding rules
            specified in this specification for the purpose of constructing the signature base
            string exclude the use of a <spanx style="verb">+</spanx> character (ASCII code 43)
            to represent an encoded space character (ASCII code 32), this practice is widely
            used in <spanx style="verb">application/x-www-form-urlencoded</spanx> encoded
            values, and MUST be properly decoded, as demonstrated by one of the
            <spanx style="verb">a3</spanx> parameter instances (the <spanx style="verb">a3</spanx>
            parameter is used twice in this request).
          </t>
        </section>

        <section title="Parameters Normalization" anchor="sig_norm_param">
          <t>
            The parameters collected in <xref target="collect_param" /> are normalized into a
            single string as follows:

            <list style="numbers">
              <t>
                First, the name and value of each parameter are <xref target="encoding">encoded</xref>.
              </t>
              <t>
                The parameters are sorted by name, using ascending byte value ordering. If
                two or more parameters share the same name, they are sorted by their value.
              </t>
              <t>
                The name of each parameter is concatenated to its corresponding value using an
                <spanx style="verb">=</spanx> character (ASCII code 61) as separator, even if the
                value is empty.
              </t>
              <t>
                The sorted name/value pairs are concatenated together into a single string by
                using an <spanx style="verb">&amp;</spanx> character (ASCII code 38) as separator.
              </t>
            </list>
          </t>
          <t>
            For example, the list of parameters from the previous section would be normalized as
            follows:
          </t>
          <texttable>
            <preamble>
              Encoded:
            </preamble>
            <ttcol align='center'>Name</ttcol>
            <ttcol align='center'>Value</ttcol>
            <c>b5</c>
            <c>%3D%253D</c>
            <c>a3</c>
            <c>a</c>
            <c>c%40</c>
            <c></c>
            <c>a2</c>
            <c>r%20b</c>
            <c>oauth_consumer_key</c>
            <c>9djdj82h48djs9d2</c>
            <c>oauth_token</c>
            <c>kkk9d7dh3k39sjv7</c>
            <c>oauth_signature_method</c>
            <c>HMAC-SHA1</c>
            <c>oauth_timestamp</c>
            <c>137131201</c>
            <c>oauth_nonce</c>
            <c>7d8f3e4a</c>
            <c>c2</c>
            <c></c>
            <c>a3</c>
            <c>2%20q</c>
          </texttable>
          <texttable>
            <preamble>
              Sorted:
            </preamble>
            <ttcol align='center'>Name</ttcol>
            <ttcol align='center'>Value</ttcol>
            <c>a2</c>
            <c>r%20b</c>
            <c>a3</c>
            <c>2%20q</c>
            <c>a3</c>
            <c>a</c>
            <c>b5</c>
            <c>%3D%253D</c>
            <c>c%40</c>
            <c></c>
            <c>c2</c>
            <c></c>
            <c>oauth_consumer_key</c>
            <c>9djdj82h48djs9d2</c>
            <c>oauth_nonce</c>
            <c>7d8f3e4a</c>
            <c>oauth_signature_method</c>
            <c>HMAC-SHA1</c>
            <c>oauth_timestamp</c>
            <c>137131201</c>
            <c>oauth_token</c>
            <c>kkk9d7dh3k39sjv7</c>
          </texttable>
          <texttable>
            <preamble>
              Concatenated Pairs:
            </preamble>
            <ttcol align='center'>Name=Value</ttcol>
            <c>a2=r%20b</c>
            <c>a3=2%20q</c>
            <c>a3=a</c>
            <c>b5=%3D%253D</c>
            <c>c%40=</c>
            <c>c2=</c>
            <c>oauth_consumer_key=9djdj82h48djs9d2</c>
            <c>oauth_nonce=7d8f3e4a</c>
            <c>oauth_signature_method=HMAC-SHA1</c>
            <c>oauth_timestamp=137131201</c>
            <c>oauth_token=kkk9d7dh3k39sjv7</c>
          </texttable>
          <figure>
            <preamble>
              And concatenated together into a single string (line breaks are for display
              purposes only):
            </preamble>
            <artwork xml:space="preserve"><![CDATA[
  a2=r%20b&a3=2%20q&a3=a&b5=%3D%253D&c%40=&c2=&oauth_consumer_key=9dj
  dj82h48djs9d2&oauth_nonce=7d8f3e4a&oauth_signature_method=HMAC-SHA1
  &oauth_timestamp=137131201&oauth_token=kkk9d7dh3k39sjv7
]]>
              </artwork>
          </figure>
        </section>

      </section>

      <section title="Percent Encoding" anchor="encoding">
        <t>
          Existing percent-encoding methods do not guarantee a consistent construction of the
          signature base string. The following percent-encoding method is not defined to replace
          the existing encoding methods defined by <xref target="RFC3986" /> and
          <xref target="W3C.REC-html40-19980424" />. It is used only in the construction of the
          signature base string.
        </t>
        <t>
          This specification defines the following method for percent-encoding strings:

          <list style="numbers">
            <t>
              Text values are first encoded as UTF-8 octets per <xref target="RFC3629" /> if they are
              not already. This does not include binary values which are not intended for human
              consumption.
            </t>
            <t>
              The values are then escaped using the <xref target="RFC3986" /> percent-encoding
              (%XX) mechanism as follows:

              <list style="symbols">
                <t>
                  Characters in the unreserved character set as defined by <xref target="RFC3986" />
                  section 2.3 (ALPHA, DIGIT, "-", ".", "_", "~") MUST NOT be encoded.
                </t>
                <t>
                  All other characters MUST be encoded.
                </t>
                <t>
                  The two hexadecimal characters used to represent encoded characters MUST be
                  upper case.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>
          This method is different from the encoding scheme used by the
          <spanx style="verb">application/x-www-form-urlencoded</spanx> content-type (for example,
          it encodes space characters as <spanx style="verb">%20</spanx> and not using the
          <spanx style="verb">+</spanx> character). It MAY be different from the
          percent-encoding functions provided by web development frameworks (e.g. encode different
          characters, use lower case hexadecimal characters).
        </t>
      </section>

    </section>

    <section title="Security Considerations" anchor="Security">
      <t>
        As stated in <xref target="RFC2617" />, the greatest sources of risks are usually found not
        in the core protocol itself but in policies and procedures surrounding its use. Implementers
        are strongly encouraged to assess how this protocol addresses their security requirements.
      </t>

      <section title="Credentials Transmission">
        <t>
          This specification does not describe any mechanism for obtaining or transmitting tokens.
          Methods used to obtain tokens should ensure that these transmissions are protected using
          transport-layer mechanisms such as TLS or SSL.
        </t>
      </section>

      <section title="Plain Method" anchor="plain_ssl">
        <t>
          When used with the <spanx style="verb">Plain</spanx> method, the protocol makes no
          attempt to protect credentials from eavesdroppers or man-in-the-middle attacks. The
          <spanx style="verb">Plain</spanx> method is only intended to be used in conjunction
          with a transport-layer security mechanism such as TLS or SSL which does provide such
          protection, or in combination with other security mechanisms.
        </t>
      </section>

      <section title="Confidentiality of Requests">
        <t>
          While this protocol provides a mechanism for verifying the integrity of requests, it
          provides no guarantee of request confidentiality. Unless further precautions are taken,
          eavesdroppers will have full access to request content. Servers should carefully consider
          the kinds of data likely to be sent as part of such requests, and should employ
          transport-layer security mechanisms to protect sensitive resources.
        </t>
      </section>

      <section title="Spoofing by Counterfeit Servers">
        <t>
          This protocol makes no attempt to verify the authenticity of the server. A hostile party
          could take advantage of this by intercepting the client's requests and returning
          misleading or otherwise incorrect responses. Service providers should consider such
          attacks when developing services using this protocol, and should require transport-layer
          security for any requests where the authenticity of the server or of request responses is
          an issue.
        </t>
      </section>

      <section title="Plaintext Storage of Credentials">
        <t>
          The token shared-secret function the same way passwords do in traditional authentication
          systems. In order to compute the signatures used in methods, the server must have access
          to these secrets in plaintext form. This is in contrast, for example, to modern operating
          systems, which store only a one-way hash of user credentials.
        </t>
        <t>
          If an attacker were to gain access to these secrets - or worse, to the server's database
          of all such secrets - he or she would be able to perform any action on behalf of any
          resource owner. Accordingly, it is critical that servers protect these secrets from
          unauthorized access.
        </t>
      </section>

      <section title="Scoping of Access Requests">
        <t>
          By itself, this protocol does not provide any method for scoping the access rights
          granted to a client. However, most applications do require greater granularity of access
          rights. For example, servers may wish to make it possible to grant access to some
          protected resources but not others, or to grant only limited access (such as read-only
          access) to those protected resources.
        </t>
        <t>
          When implementing this protocol, servers should consider the types of access resource
          owners may wish to grant clients, and should provide mechanisms to do so. Servers should
          also take care to ensure that resource owners understand the access they are granting, as
          well as any risks that may be involved.
        </t>
      </section>

      <section title="Entropy of Secrets">
        <t>
          Unless a transport-layer security protocol is used, eavesdroppers will have full access
          to authenticated requests and signatures, and will thus be able to mount offline brute-force
          attacks to recover the credentials used. Servers should be careful to assign
          shared-secrets which are long enough, and random enough, to resist such attacks for at
          least the length of time that the shared-secrets are valid.
        </t>
        <t>
          For example, if shared-secrets are valid for two weeks, servers should ensure that it is
          not possible to mount a brute force attack that recovers the shared-secret in less than
          two weeks. Of course, servers are urged to err on the side of caution, and use the longest
          secrets reasonable.
        </t>
        <t>
          It is equally important that the pseudo-random number generator (PRNG) used to generate
          these secrets be of sufficiently high quality. Many PRNG implementations generate number
          sequences that may appear to be random, but which nevertheless exhibit patterns or other
          weaknesses which make cryptanalysis or brute force attacks easier. Implementers should be
          careful to use cryptographically secure PRNGs to avoid these problems.
        </t>
      </section>

      <section title="Denial of Service / Resource Exhaustion Attacks">
        <t>
          This specification includes a number of features which may make resource exhaustion
          attacks against servers possible. For example, this protocol requires servers to track
          used nonces. If an attacker is able to use many nonces quickly, the resources required to
          track them may exhaust available capacity. And again, this protocol can require servers
          to perform potentially expensive computations in order to verify the signature on
          incoming requests. An attacker may exploit this to perform a denial of service attack by
          sending a large number of invalid requests to the server.
        </t>
        <t>
          Resource Exhaustion attacks are by no means specific to this specification. However,
          implementers should be careful to consider the additional avenues of attack that this
          protocol exposes, and design their implementations accordingly. For example, entropy
          starvation typically results in either a complete denial of service while the system
          waits for new entropy or else in weak (easily guessable) secrets. When implementing this
          protocol, servers should consider which of these presents a more serious risk for their
          application and design accordingly.
        </t>
      </section>

      <section title="Signature Base String Limitations">
        <t>
          The signature base string has been designed to support the signature methods defined in
          this specification. Those designing additional signature methods, should evaluated the
          compatibility of the signature base string with their security requirements.
        </t>
        <t>
          Since the signature base string does not cover the entire HTTP request, such as most
          request entity-body, most entity-headers, and the order in which parameters are sent,
          servers should employ additional mechanisms to protect such elements.
        </t>
      </section>

		</section>

    <section title="IANA Considerations" anchor="IANA">
      <t>
        This memo includes no request to IANA.
      </t>
    </section>

    <section title="Acknowledgments">
      <t>
        Richard Barnes, Breno de Medeiros, Brian Eaton, Ben Laurie, Mark Nottingham, John Panzer, Peter Saint-Andre
      </t>
    </section>

    <appendix title="Document History" anchor="history">
      <t>
        [[ To be removed by the RFC editor before publication as an RFC. ]]
      </t>
      <t>
        -00

        <list style="symbols">
          <t>
            Initial draft.
          </t>
        </list>
      </t>
    </appendix>

  </middle>

  <back>

    <references title="Normative References">

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html40-19980424.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p1-messaging-08.xml"?>
      
    </references>

    <references title="Informative References">

      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-web-delegation-01.xml"?>

    </references>
  </back>

</rfc>