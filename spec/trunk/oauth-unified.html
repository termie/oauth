<html>
<head>
<title>OAuth 1.0 RC Unified Revision 107</title>
</head>
<body>
<h1>OAuth 1.0 Draft Unified Revision 107</h1>

<h2>Authors</h2>

<ul>
<li><span class="vcard"><span class="fn">Mark Atwood</span> (<span class="email">me@mark.atwood.name</span>)</span></li>
<li><span class="vcard"><span class="fn">Richard M. Conlan</span> (<span class="email">zeveck@google.com</span>)</span></li>
<li><span class="vcard"><span class="fn">Blaine Cook</span> (<span class="email">blaine@twitter.com</span>)</span></li>
<li><span class="vcard"><span class="fn">Leah Culver</span> (<span class="email">leah@pownce.com</span>)</span></li>
<li><span class="vcard"><span class="fn">Kellan Elliott-McCrea</span> (<span class="email">kellan@yahoo-inc.com</span>)</span></li>
<li><span class="vcard"><span class="fn">Larry Halff</span> (<span class="email">larry@ma.gnolia.com</span>)</span></li>
<li><span class="vcard"><span class="fn">Eran Hammer-Lahav</span> (<span class="email">eran@hueniverse.com</span>)</span></li>
<li><span class="vcard"><span class="fn">Ben Laurie</span> (<span class="email">benl@google.com</span>)</span> </li>
<li><span class="vcard"><span class="fn">Chris Messina</span> (<span class="email">chris@citizenagency.com</span>)</span></li>
<li><span class="vcard"><span class="fn">John Panzer</span> (<span class="email">jpanzer@acm.org</span>)</span></li>
<li><span class="vcard"><span class="fn">David Recordon</span> (<span class="email">david@sixapart.com</span>)</span></li>
<li><span class="vcard"><span class="fn">Eran Sandler</span> (<span class="email">eran@yedda.com</span>)</span></li>
<li><span class="vcard"><span class="fn">Jonathan Sergent</span> (<span class="email">sergent@google.com</span>)</span></li>
<li><span class="vcard"><span class="fn">Todd Sieling</span> (<span class="email">todd@ma.gnolia.com</span>)</span></li>
<li><span class="vcard"><span class="fn">Andy Smith</span> (<span class="email">andy@jaiku.com</span>)</span></li>
</ul>

<h2>Description</h2>

<p>The OAuth protocol enables websites or applications (Consumers) to access Protected Resources from a web service (Service Provider) via an API, without requiring the User to disclose their Service Provider credentials to the Consumer. An example use case is allowing printing service print.example.com (the Consumer), to access private photos stored on photos.example.com (the Service Provider) without requiring the User to provide their photos.example.com credentials to print.example.com.</p>

<p>More generally, OAuth creates a freely-implementable and generic methodology for API authentication, benefitting developers who want their Consumer product to interact with various Service Providers.</p>

<p>While OAuth does not require a specific user interface or interaction pattern, recommendations and emerging best practices are described in this specification. Additionally, OAuth does not specify how Service Providers authenticate Users, making the protocol ideally suited for cases where authentication credentials are unavailable to the Consumer, such as with OpenID.</p>

<p>OAuth aims to unify the experience and implementation of delegated web service authentication into a single, community-driven protocol. OAuth builds on existing protocols and best practices that have been independently implemented by various websites. An open standard, supported by large and small providers alike, promotes a consistent and trusted experience for both application developers and the users of those applications.</p>

<h2>Notation and Conventions</h2>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.</p>

<h2>Definitions</h2>

<ul>
<li>Service Provider
: A web application that allows access via OAuth. </li>
<li>User
: An individual who has an account with the Service Provider. </li>
<li>Consumer
: A website or application that uses OAuth to access the Service Provider on behalf of the User. </li>
<li>Protected Resource(s)
: Data controlled by the Service Provider, which the Consumer can access through authentication.</li>
<li>Consumer Developer
: An individual or organization that implements a Consumer. </li>
<li>Consumer Key
: A value used by the Consumer to identify itself to the Service Provider. </li>
<li>Consumer Secret
: A secret used by the Consumer to establish ownership of the Consumer Key.</li>
<li>Token
: A value used by the Consumer to gain access to the Protected Resources on behalf of the User, instead of using the User's Service Provider credentials. There are two types of Tokens: Request Token and Access Token.</li>
<li>Token Secret
: A secret used by the Consumer to establish ownership of a given Token.</li>
<li>Authorization Endpoint URL
: A Service Provider URL used by the User to grant Consumer access.</li>
<li>API Endpoint URLs
: Service Provider URLs used by the Consumer API requests, including obtaining and exchanging Tokens.</li>
<li>Callback Endpoint URL
: A web-based Consumer URL used by Service Provider to notify when the User grants or denies access.</li>
<li>Protocol Parameters
: Parameters with names beginning with <code>oauth_</code>.</li>
</ul>

<h2>Consumer Types</h2>

<p>Consumers are categorized based on their ability to accept incoming HTTP(S) requests. OAuth defines two Consumer types:</p>

<ul>
<li>Web-Based Consumer
: A website or other web-based application capable of accepting incoming HTTP(S) requests.</li>
<li>Limited Consumer
: An application running on a User device (desktop, mobile, set-top box, etc.) incapable of accepting incoming HTTP(S) requests.</li>
</ul>

<h2>Endpoint URLs</h2>

<p>All Endpoint URLs for both Service Providers and Consumers MUST include scheme, authority, and path, and MUST NOT include query or fragment as defined by RFC 3986 section 3. Service Providers MAY specify additional query parameters to be used with the Authorization and API Endpoint URLs, but those parameters are not considered part of the Endpoint URL.</p>

<h2>Setting Up to Use OAuth</h2>

<p>OAuth includes a Consumer Key and matching Consumer Secret that together authenticate the Consumer (as opposed to the User) to the Service Provider. Consumer-specific identification allows the Service Provider to vary access levels to Consumers (such as un-throttled API access or other resources).</p>

<p>Service Providers MUST NOT rely on the Consumer Secret as a method to verify the Consumer identity, unless the Consumer Secret is known to be inaccessible to anyone other than the Consumer and the Service Provider. When displaying any identifying information about the Consumer to the User based on the Consumer Key, the Service Provider MUST inform the User if it is unable to assure the Consumer’s true identity. The method in which the Service Provider informs the User and the quality of the identity assurance is beyond the scope of this specification.</p>

<p>For example, the Consumer Key and Consumer Secret of a desktop application running on a User desktop can be extracted and abused, while a Consumer Key and Consumer Secret stored on a web server behind a firewall can be assumed safe.</p>

<h3>Service Providers</h3>

<p>Service Providers MUST enable Consumer Developers to obtain a Consumer Key and Consumer Secret. The process and requirements for provisioning these are entirely up to the Service Providers unless where otherwise specified.</p>

<p>The Consumer Secret MAY be either a randomized string or a public/private key pair. In the case that the Consumer Secret is a public/private key pair, the Service Provider only requires the public key, and SHOULD verify that the Consumer Developer is, in fact, the owner of the private key.</p>

<p>The Service Provider MUST also provide documentation to specify:</p>

<ol>
<li>The Authorization Endpoint URL and the API Endpoint URLs that the Consumer will use when making OAuth requests.</li>
<li>Signature algorithms supported by the Service Provider.</li>
<li>Any additional request parameters that the Service Provider requires in order to obtain a Token. Service Provider specific parameters MUST NOT begin with <code>oauth.</code>.</li>
</ol>

<h3>Consumers</h3>

<p>The Consumer Developer MUST establish a Consumer Key and a Consumer Secret with the Service Provider.</p>

<p>When registering a Consumer Key, the Consumer Developer MUST identify the Consumer type (web-based or limited). If the Consumer is web-based, the Consumer Developer MUST provide the Callback Endpoint URL where the Service Provider notifies the Consumer when the User grants or denies access.</p>

<h2>Parameters</h2>

<p>Protocol Parameters' names and values are case sensitive. Each Protocol Parameter MUST NOT appear more than once per request.</p>

<h3>Parameter Encoding</h3>

<p>All parameter names and values are escaped using the RFC 3986 percent-encoding (%xx) mechanism. Characters not in the unreserved character set (RFC 3986 section 2.3) MUST be encoded. Characters in the unreserved character set MUST NOT be encoded. Hexadecimal characters in encodings MUST be upper case. Text names and values MUST be encoded as UTF-8 octets before percent-encoding them.</p>

<h3>Request Parameters</h3>

<p>Protocol Parameters are sent from the Consumer to the Service Provider in one of two methods:</p>

<ol>
<li>Added to the API Endpoint URL in the query part (as defined by RFC 3986 section 3).</li>
<li>In the HTTP <code>Authorization</code> header as defined in "Using HTTP-Authorization Headers".</li>
</ol>

<h3>Response Parameters</h3>

<p>Response parameters are sent by the Service Provider to return Tokens and other information to the Consumer in the HTTP response body. The parameters are first encoded and then sent as a sequence of lines. Each line begins with a parameter name, followed by an = character (ASCII code 61), and the parameter value. The line is terminated by a single newline character (ASCII code 10). Additional characters, including whitespace, MUST NOT be added before or after the = or newline characters.</p>

<h2>User Authentication and Consumer Access Grants</h2>

<p>OAuth does not specify how the Service Provider authenticates the User. However, it does provide a set of steps to verify User identity and obtain approval to grant the Consumer access to the Protected Resources.</p>

<ul>
<li>The Service Provider MUST first verify the User's identity before asking for consent. It MAY prompt the User to sign in if the User has not already done so.</li>
<li>The Service Provider presents to the User information about the Consumer requesting access (as registered by the Consumer Developer). The information MUST include the duration of the access and the Protected Resources provided. The information MAY include other details specific to the Service Provider.</li>
<li>The User MUST grant or deny permission for the Service Provider to give the Consumer access to the Protected Resources on behalf of the User. Permission MUST be granted for the protocol flow to continue. If the User denies the Consumer access, the Service Provider MUST NOT allow access to the Protected Resources.</li>
</ul>

<h2>Authenticating with OAuth</h2>

<p>OAuth authentication is the process in which Users grant access to their Protected Resources without sharing their credentials with the Consumer. OAuth uses Tokens generated by the Service Provider instead of the User’s credentials in API requests. The process uses two Token types:</p>

<ul>
<li>Request Token
: Used by the Consumer to ask the USER to authorize access to the Protected Resources. The authorized Request Token MUST be exchanged for an Access Token, SHALL only be used once, and SHALL NOT be used for any other purpose. Request Tokens SHOULD have a limited lifetime.</li>
<li>Access Token
: Used by the Consumer to access the Protected Resources on behalf of the User. Access Tokens MAY limit access to certain Protected Resources, and MAY have a defined lifetime. Service Providers SHOULD allow Users to revoke Access Tokens.</li>
</ul>

<p>OAuth Authentication is done in two broad steps. First, the Consumer obtains an authorized Request Token. Second, the Consumer exchanges the Request Token for an Access Token. Only the Access Token SHALL be used to access the Protect Resources.</p>

<h3>Obtaining a Request Token</h3>

<p>The Consumer obtains an authorized Request Token by asking the Service Provider to issue a Token, and having the User to authorize it. The Request Token sole purpose is to receive User approval and can only be used to obtain an Access Token. The Request Token process goes as follows:</p>

<ol>
<li>Consumer requests a Request Token</li>
<li>Service Provider issues an unauthorized Request Token</li>
<li>Consumer directs the User to the Service Provider</li>
<li>Service Provider authenticates the User and obtains consent</li>
<li>Service Provider directs the User back to the Consumer</li>
</ol>

<h4>1. Consumer Requests a Request Token</h4>

<p>To obtain a Request Token, the Consumer sends an HTTP GET request to the Service Provider's API Endpoint URL for Request Token requests. The request MUST be signed per "Signing API Requests", and contains the following parameters:</p>

<ul>
<li><code>oauth.consumer_key</code>
: The Consumer Key.</li>
<li><code>oauth.token_attributes</code>
: OPTIONAL. Service Provider specific value used to indicate the type of access, resources, duration, and other Token attributes. </li>
<li><code>oauth.signature_method</code>
: The signature method the Consumer used to sign the request.</li>
<li><code>oauth.signature</code>
: The signature as defined in "Signing API Requests".</li>
<li><code>oauth.state</code>
: OPTIONAL. This parameter will be returned unmodified to the Consumer. This parameter is only available to web-based Consumers, and SHOULD only be used in the case of stateless Consumers. The value is returned via the Callback Endpoint URL.</li>
<li><code>oauth.version</code>
: OPTIONAL. If present, value MUST be <code>1.0</code>. Service Providers MUST assume the protocol version to be <code>1.0</code> if this parameter is not present. Service Providers’ response to non-<code>1.0</code> value is left undefined.</li>
<li>Any additional parameters, as defined by the Service Provider.</li>
</ul>

<h4>2. Service Provider Issues an Unauthorized Request Token</h4>

<p>The Service Provider verifies the Consumer Key and if successful, generates a Request Token and Token Secret and returns them to the Consumer in the HTTP response body as defined in "Response Parameters". The Service Provider MUST ensure the Request Token cannot be exchanged for an Access Token until the User successfully grants access in step 4 below.</p>

<p>The response contains the following parameters:</p>

<ul>
<li><code>oauth.token</code>
: The Request Token.</li>
<li><code>oauth.token_secret</code>
: The Token Secret.</li>
<li>Any additional parameters, as defined by the Service Provider.</li>
</ul>

<p>If the request fails verification, the Service Provider MUST respond with an HTTP 401 Not Authorized, and MAY include some further details about why the request was not authorized in the HTTP response body as defined in "Response Parameters".</p>

<h4>3. Consumer Directs the User to the Service Provider</h4>

<p>In order for the Consumer to be able to exchange the Request Token for an Access Token, the Consumer MUST obtain approval from the User by directing the User to the Service Provider. The Consumer constructs an HTTP GET request to the Service Provider's Authorization Endpoint URL with the following parameter:</p>

<ul>
<li><code>oauth.token</code>
: OPTIONAL. The Request Token obtained in the previous step. The Service Provider MAY declare this parameter as REQUIRED, or accept requests to the Authorization Endpoint URL without it, in which case it will prompt the User to enter it manually.</li>
</ul>

<p>Once the request URL has been constructed the Consumer redirects the User to the URL via the User's web browser. If the Consumer is incapable of automatic HTTP redirection, the Consumer SHALL notify the User how to manually go to the constructed request URL.</p>

<p>Note: If a Service Provider knows a Consumer to be running on a mobile device or set-top box, the Service Provider SHOULD ensure that the Authorization Endpoint URL and Request Token are suitable for manual entry.</p>

<h4>4. Service Provider Authenticates the User and Obtains Consent</h4>

<p>The Service Provider verifies the User's identity and asks for consent as detailed in the "User Authentication and Consumer Access Grants" section.</p>

<h4>5. Service Provider Directs the User Back to the Consumer</h4>

<p>After the User authenticates with the Service Provider and grants permission for Consumer access, the Consumer MUST be notified that the Request Token has been authorized and ready to be exchanged for an Access Token. If the User denies access, the Consumer MAY be notified that the Request Token has been revoked.</p>

<p>The Consumer notification method is based on the Consumer type as follows:</p>

<h5>Web-Based Consumers</h5>

<p>The Service Provider constructs an HTTP GET request to the Consumer's Callback Endpoint URL with the following parameters:</p>

<ul>
<li><code>oauth.token</code>
: The Request Token the User authorized or denied.</li>
<li><code>oauth.result</code>
: <code>true</code> if the User grants access, <code>false</code> if the User denies access.</li>
<li><code>oauth.state</code>
: REQUIRED if one was provided in the Consumer Request Token request.</li>
</ul>

<p>Once the request URL has been constructed the Service Provider redirects the User to the URL via the User's web browser.</p>

<h5>Limited Consumers</h5>

<p>The Service Provider instructs the User to inform the Consumer that authorization has completed. Since Limited Consumers cannot accept incoming HTTP(S) requests, the User will need to manually notify the Consumer when they are done.</p>

<p>The Service Provider MAY include two machine-readable tags in its human-readable instructions to the User. If included, both tags MUST be added in the <head> element of the HTML document:</p>

<pre><code> &lt;meta name="oauth.result" content="true" /&gt;
 &lt;meta name="oauth.token" content="single_use_token" /&gt;
</code></pre>

<p>In the <code>oauth.result</code> tag, the <code>content</code> attribute indicates whether access was granted, true<code>if the User grants access,</code>false<code>if the User denies access. In the</code>oauth.token<code>tag, the</code>content` attributes is the Request Token approved or denied.</p>

<h3>Obtaining an Access Token</h3>

<p>Obtaining an Access Token follows the same process for all Consumer types:</p>

<ol>
<li>Consumer Requests an Access Token</li>
<li>Service Provider Grants an Access Token</li>
</ol>

<h4>1. Consumer Requests an Access Token</h4>

<p>The Request Token and Token Secret MUST be exchanged for an Access Token and Token Secret.</p>

<p>To request as Access Token, the Consumer makes an HTTP request to Service Provider API Endpoint URL for Token exchange. The Service Provider documentation MUST specify either HTTP GET or POST for this endpoint. It is RECOMMENDED that this be a POST request. The request MUST be signed per "Signing API Requests".</p>

<p>The request contains the following parameters:</p>

<ul>
<li><code>oauth.consumer_key</code>
: The Consumer Key.</li>
<li><code>oauth.token</code>
: The Request Token obtained previously.</li>
<li><code>oauth.signature_method</code>
: The signature method the Consumer used to sign the request.</li>
<li><code>oauth.signature</code>
: The signature as defined in "Signing API Requests".</li>
</ul>

<p>No additional Service Provider specific parameters are allowed when requesting an Access Token to ensure all Token related information is present prior to seeking User approval.</p>

<h4>2. Service Provider Grants an Access Token</h4>

<p>The Service Provider exchanges the Consumer's Authorization for a new Access Token and Token Secret. The Service Provider MUST verify that:</p>

<ul>
<li>The request is properly signed.</li>
<li>The Request Token has not been exchanged before for an Access Token.</li>
<li>The Request Token matches the Consumer Key.</li>
</ul>

<p>On successful verification, the Service Provider returns an Access Token and a Token Secret in the HTTP response body as defined in "Response Parameters". The Access Token and Token Secret are stored by the Consumer to use when signing future API requests.</p>

<p>The response contains the following parameters:</p>

<ul>
<li><code>oauth.token</code>
: The Access Token.</li>
<li><code>oauth.token_secret</code>
: The Token Secret.</li>
<li>Any additional parameters, as defined by the Service Provider.</li>
</ul>

<p>If the request is unsuccessful, the Service Provider MUST respond with an HTTP 401 Not Authorized, and MAY include some further details about why the request was not authorized in the HTTP response body as defined in "Response Parameters".</p>

<h2>Accessing Protected Resources</h2>

<p>After successfully receiving the Access Token and Token Secret, the Consumer is able to access the Protected Resources on behalf of the User.</p>

<p>The request contains the following parameters:</p>

<ul>
<li><code>oauth.consumer_key</code>
: The Consumer Key.</li>
<li><code>oauth.token</code>
: The Access Token.</li>
<li><code>oauth.signature_method</code>
: The signature method the Consumer used to sign the request.</li>
<li><code>oauth.signature</code>
: The signature as defined in "Signing API Requests".</li>
<li>Any additional parameters, as defined by the Service Provider.</li>
</ul>

<h2>Signing API Requests</h2>

<p>The purpose of signing API requests is to prevent unauthorized parties from using the Consumer Key and Tokens when making API Endpoint URL requests. The signature process encodes the Consumer Secret and Token Secret into a verifiable value which is included with the request.</p>

<p>OAuth does not require a particular signature method, as each API implementation can have its own unique requirements. The protocol defines three signature methods: <code>PLAINTEXT</code>, <code>HMAC-SHA1</code>, and <code>RSA</code>, but Service Providers are free to implement and document their own methods. Recommending any particular method is beyond the scope of this specification.</p>

<p>All API Endpoint URL requests MUST be signed by the Consumer and verified by the Service Provider. Both the Consumer and Service Provider follow the same process to generate the request signature.</p>

<p>The Consumer declares a signature method in the <code>oauth.signature_method</code> parameter, and generates a signature which is includes in the <code>oauth.signature</code> parameter. The Service Provider verifies the request by generating a new request signature based on the Consumer specified method, and compares it to the signature provided by the Consumer.</p>

<p>The signature process MUST NOT change the request parameter names or values. It is a read-only process on the request. All request parameters MUST be encoded as described in "Parameter Encoding" prior to applying the signature process.</p>

<h3>PLAINTEXT</h3>

<p>The <code>PLAINTEXT</code> method does not provide any security protection and SHOULD be used over a secure channel such as HTTPS. The signature Protocol Parameters are set with the following values unencrypted:</p>

<ul>
<li><code>oauth.signature_method</code>
: Set to <code>PLAINTEXT</code>.</li>
<li><code>oauth.signature</code>
: Set to the concatenated value of the <code>oauth.consumer_secret</code> parameter and the value of the <code>oauth.token_secret</code> parameter. The values are separated by a <code>,</code> character (ASCII code 44), even if empty.</li>
</ul>

<h3>HMAC-SHA1</h3>

<p>The <code>HMAC-SHA1</code> method includes the following steps:</p>

<ol>
<li>Normalize Service Provider request parameters</li>
<li>Generate a Nonce</li>
<li>Concatenate parameters into a string</li>
<li>Calculate HMAC value</li>
<li>Set Signature parameters</li>
</ol>

<h4>1. Normalize Service Provider Request Parameters</h4>

<p>All non-Protocol Parameters SHALL be normalized as follows into a single string:</p>

<ol>
<li>Parameters are sorted by name, using lexicographical byte value ordering. If two or more parameters share the same name, they are sorted by their value. For example: <code>a=1</code>, <code>c=hi%20there</code>, <code>f=25</code>, <code>f=50</code>, <code>z=10</code>.</li>
<li>Parameters are concatenated in their sorted order into a single string. For each parameter, the name is separated from the corresponding value by an = character (ASCII code 61). Each name-value pair is separated by an <code>&amp;</code> character (ASCII code 38). For example: <code>a=1&amp;c=hi%20there&amp;f=25&amp;f=50&amp;z=10</code></li>
<li>The concatenated string is encoded as described in "Parameter Encoding".</li>
</ol>

<h4>2. Generate a Nonce and Timestamp</h4>

<p>A nonce is a random string, uniquely generated for each request. The nonce allows the Service Provider to verify that a request has never been made before and helps prevent replay attacks when requests are made over a non-secure channel (such as HTTP).</p>

<p>The Consumer SHALL first calculate the request timestamp expressed in the number of seconds since January 1, 1970 00:00:00 GMT. The Consumer SHALL then generate a Nonce values that is unique for each request with the same timestamp value.</p>

<h4>3. Concatenate Parameters into a String</h4>

<p>The Protocol Parameters and values generated in the previous two steps are concatenated into a single string used as the input to the signature algorithm. The request parameters MUST be concatenated in the following order:</p>

<ol>
<li><code>oauth.consumer_key</code></li>
<li><code>oauth.consumer_secret</code></li>
<li><code>oauth.token</code></li>
<li><code>oauth.token_secret</code></li>
<li>The HTTP request method used to send the request. Value MUST be uppercase, for example: <code>HEAD</code>, <code>GET</code>, <code>POST</code>, etc.</li>
<li>The API Endpoint URL as defined in "Endpoint URLs".</li>
<li>The normalized Service Provider request parameter result string from step 1.</li>
<li>The HTTP request body.</li>
<li>The timestamp value from step 2.</li>
<li>The nonce value from step 2.</li>
</ol>

<p>The above request parameters and generated values are concatenated in order into a single string. For each Protocol Parameter, the name is separated from the corresponding value by an = character (ASCII code 61). If a Protocol Parameter is not present in the request, the parameter is included with an empty value. Each signature item is separated by an <code>&amp;</code> character (ASCII code 38), even if empty.</p>

<h4>4. Calculate HMAC value</h4>

<p>The HMAC-SHA1 value of the concatenated string from step 3 is calculated as defined in RFC 2104:</p>

<p>hmac_sha1(oauth.consumer_secret, concatenated_string)</p>

<h4>5. Set Signature Parameters</h4>

<p>The signature Protocol Parameters are set with the following values:</p>

<ul>
<li><code>oauth.signature_method</code>
: Set to <code>HMAC-SHA1</code>.</li>
<li><code>oauth.signature</code>
: Set to the concatenated values of the timestamp value from step 2, the nonce value from step 2, and the calculated HMAC value from step 4. Each value is separated by an <code>,</code> character (ASCII code 44).</li>
</ul>

<h3>RSA</h3>

<dl>
<dt>-- Not yet done - ignore</dt>
<dt>* <code>oauth.signature=openssl_x509_sign</code></dt>
<dd>openssl_x509_sign(private_certificate, concatenated_string). In the case of using x509 certs, the Service Provider would have the Consumer's public key and therefore would provide an empty string as the secret.</dd>
</dl>

<h2>Using HTTP-Authorization Headers</h2>

<p>This section defines an RFC 2617 extension to support OAuth. It uses the standard HTTP Authorization and WWW-Authenticate headers to pass credentials rather than using URL parameters. All Consumers SHOULD be able to supply an OAuth Authorization header as an alternative to passing URL parameters. It is RECOMMENDED that Service Providers accept such a header, and such Service Providers MUST signal Consumers by returning the OAuth WWW-Authenticate header upon all requests for the Protected Resources. For the remainder of this section, we assume that the Service Provider under discussion has chosen to support this extension.</p>

<p>When using an HTTP-Authorization header, the Protocol Parameters are not included in the request URL. Rather they are included as the value of the header.</p>

<pre><code>`Authorization: OAuth oauth.token="540ad18" oauth.consumer_key="0685bd91" oauth.signature_method="PLAINTEXT" oauth.signature="2d047740b53,bb5c2a0f398f30"`
</code></pre>

<p>To reject a request that lacks appropriate credentials, the Service Provider MUST respond with a 401 Unauthorized response. Such a response MUST include at least one OAuth WWW-Authenticate header and MAY include additional WWW-Authenticate headers:</p>

<pre><code>`401 Unauthorized`
...
`WWW-Authenticate: OAuth realm="https://sp.example.com/oauth/authorize?res=74637288"`
</code></pre>

<p>The realm parameter both defines a protection realm per RFC 2617, section 1.2, and also specifies the Authorization Endpoint URL to be used by the Consumer to obtain authorization for the accessed resource.</p>

<p>A Consumer MAY also include an empty, token-less OAuth Authorization header on any HTTP request to inform a Service Provider that it supports OAuth. The Service Provider MUST then respond with the appropriate WWW-Authenticate header for the requested resource in the response. For example, a Consumer could inquire using HEAD and then adjust its UI if the Service Provider supports OAuth.</p>

<h2>Error Messages</h2>

<ul>
<li>HTTP 400 Bad Request

<ul>
<li>Invalid Timestamp</li>
<li>Unsupported Signature Algorithm</li>
</ul></li>
<li>HTTP 401 Unauthorized

<ul>
<li>Invalid Consumer Key</li>
<li>Invalid/Expired Token</li>
<li>Invalid Signature</li>
<li>Nonce Spent</li>
</ul></li>
</ul>
</body>
</html>