# OAuth 0.9

## Authors

* Mark Atwood (me@mark.atwood.name)
* Blaine Cook (blaine@twitter.com)
* Leah Culver (leah@pownce.com)
* Kellan Elliott-McCrea (kellan@flickr.com)
* Larry Halff (larry@mag.nolia.com)
* Eran Hammer-Lahav (eran@hueniverse.com)
* Ben Laurie (benl@google.com) 
* Chris Messina (chris@citizenagency.com)
* John Panzer (jpanzer@acm.org)
* David Recordon (drecordon@sixapart.com)
* Eran Sandler (eran.sandler@gmail.com)
* Jonathan Sergent (sergent@google.com)
* Andy Smith (andy@jaiku.com)

## Description

The OAuth protocol enables websites or applications (Consumers) to access Protected Resources from a web service (Service Provider) via an API, without requiring the User to provide their Service Provider credentials to the Consumer. An example use case is allowing printing service print.example.com (the Consumer), to access private photos stored on photos.example.com (the Service Provider) without requiring the User to provide their photos.example.com credentials to print.example.com.

More generally, OAuth creates a freely-implementable and generic methodology for API
authentication, benefitting developers who want their Consumer product to
interact with various Service Providers.

While OAuth does not require a specific user interface or interaction pattern, recommendations and emerging best practices are described
in this specification. Additionally, OAuth does not specify how Service Providers  authenticate
Users, making the protocol ideally suited for cases where authentication
credentials are unavailable to the Consumer, such as with OpenID. 

## Background
 
OAuth aims to unify the experience and implementation of delegated web service
authentication into a single, community-driven protocol. OAuth builds on 
existing protocols and best practices that have been independently implemented 
by various websites. An open standard, supported by large and small providers
alike, promotes a consistent and trusted experience for both consumer
application developers and the users of those applications. 

## Definitions 

* Service Provider
: A web application that allows access via OAuth. 
* User
: An individual who has an account with the Service Provider. 
* Consumer
: A website or application that uses OAuth to access the Service Provider on
  behalf of the User. 
* Consumer Developer
: An individual or organization that implements a Consumer. 
* Consumer Key
: A string used by the Consumer to identify itself to the Service Provider. 
* Consumer Secret
: A secret (specific to the Consumer Key) used by the Consumer to sign
  OAuth requests to the Service Provider.
* Protected Resource(s)
: Data controlled by the Service Provider, which the Consumer can access
  through authentication.
* Token
: A string used by the Consumer to gain access to the Protected Resource(s)
  on behalf of the User (instead of using the User's Service Provider credentials).
  There are two types of Tokens: Single-Use and Multi-Use.
* Token Secret
: A secret, specific to a Token, which the Consumer uses to
  sign its OAuth requests to the Service Provider on behalf of a User.
* Single-Use Token
: A Token generated by the Service Provider and given to the
  Consumer to identify the User in the authentication process. The
  Consumer will exchange the Single-Use Token for a Multi-Use Token after the User
  authenticates and grants access permission to the Consumer.
* Multi-Use Token
: A Token generated by the Service Provider and given to the Consumer in order to identify the User in subsequent API requests. 
* Authorization Endpoint URL
: A URL, provided by the Service Provider, that the Consumer uses to obtain
  authorization from the User for access to the Service Provider.
* API Endpoint URL
: A URL provided by the Service Provider, which the Consumer uses to make API
  requests, including obtaining Tokens.
* Callback Endpoint URL
: A URL provided by the a web Consumer, which the Service Provider uses to return a
  Single-Use Token and Token Secret.

## Protocol

### Overview 

#### Pre-Authentication
 
1. The Consumer Developer obtains a Consumer Key and a Consumer Secret from
   the Service Provider.

#### Authentication
 
1. The Consumer attempts to obtain a Single-Use Token and Token Secret on behalf of
   the User. 
   * Web-based Consumers redirect the User to the Authorization Endpoint URL. 
   * Desktop-based Consumers first obtain an unauthorized Single-Use Token by making a
     request to the API Endpoint URL then direct the User to the Authorization
     Endpoint URL.
2. The User authenticates with the Service Provider. 
3. The User grants or declines permission for the Service Provider to give the
   Consumer a Single-Use Token (or authorize an existing Single-Use Token obtained by a desktop-based Consumer). 
4. The Service Provider generates and authorizes a Single-Use Token and Token Secret to be
   exchanged for a Multi-Use Token and Token Secret.
   * For web-based Consumers the Service Provider redirects to a
     pre-established Callback Endpoint URL with the Single-Use Token
     and Token Secret it has created and authorized.
   * For Desktop-based Consumers the Service Provider instructs the User
     to inform the Consumer that authorization has completed. The Single-Use
     Token obtained in step 1 is authorized instead of generating a new Token.
   * For Mobile and Set-Top box Consumers the Service Provider displays
     the Single-Use Token and Token Secret to the User and the Consumer waits
     for the User to manually submit them through the Consumer application.
5. The Consumer exchanges the Single-Use Token and Token Secret for a Multi-Use
   Token and Token Secret.
6. The Consumer uses the Multi-Use Token, Multi-Use Token Secret, Consumer Key, and
   Consumer Secret to make authenticated requests to the Service Provider. 

#### Obtaining a Consumer Key

OAuth includes a Consumer Key and matching Consumer Secret allowing the Service
Provider to authenticate the Consumer (as opposed to authenticate the User).
This allows the Service Provider to provide different access levels to
Consumers (such as disabling API throttling or allowing access to more
resources). The Service Provider MUST allow Consumer Developers to obtain a
Consumer Key and corresponding Consumer Secret. The provisioning of these is
entirely up to the Service Provider. The Consumer Key MUST be a string
suitable for transmission in HTTP request parameters. The Consumer Secret MAY
be either a randomized string or a public/private key pair. In the case that
the Consumer Secret is a public/private key pair, the Service Provider only
requires the public key, and SHOULD verify that the Consumer Developer is in
fact the owner of the private key. 

The Service Provider MUST also provide documentation detailing the following: 

1. The endpoint URLs that the Consumer will use when making OAuth requests; 
   * Authorization Endpoint URL 
   * API Endpoint URLs
2. The Signature Algorithms supported by the Service Provider. See "Recommended
   Signature Algorithms" for a summary of best practices. 
3. Any additional request parameters that the Service Provider requires in
   order to obtain a Token.
 
When registering for a Consumer Key, the Service Provider asks the Consumer
Developer for information regarding the nature of the Consumer (web
application, desktop application, mobile application etc). If the Consumer is a
web application, the Consumer Developer MUST provide the Callback URL Endpoint where the
Service Provider will send the Single-Use Tokens.

Libraries implementing OAuth for the convenience of Consumer applications MUST
support configurable API Endpoint URLs. 

#### Obtaining a Single-Use Token 

User Interface Note: If a Service Provider expects a Consumer to be running on a Mobile
     device or Set-Top box, the Service Provider SHOULD ensure that the
     Authorization Endpoint URL, the Single-Use Token, and Token Secret are short and simple
     enough to remember for manual entry into a web browser.

#### Web-based Consumers

Web-based Consumers obtain the Single-Use Token by way of an HTTP Redirect from
the Service Provider to the Consumer's Callback Endpoint URL. The
request/response cycle is as follows:

##### Consumer Requests An Authorized Single-Use Token
 
To request a Single-Use Token, the Consumer constructs an
`application/x-www-form-urlencoded` HTTP GET request to the Service Provider's
Authorization Endpoint URL which will be sent via the User's user-agent
(i.e., web browser).

###### Request

The request contains the following parameters:

* `oauth_consumer_key` - The Consumer Key 
* `oauth_state` (OPTIONAL) - An `application/x-www-form-urlencoded` string that
  will be passed through unmodified to the Consumer (this parameter SHOULD only
  be used in the case of stateless web-based Consumers) 
* any additional parameters, as defined by the Service Provider.

Once the request URL has been generated the Consumer issues an HTTP 302
Redirect to the Service Provider using that URL.
 
###### Example 

In this example, the Consumer is requesting a Single-Use Token from the
Authorization Endpoint URL `https://sp.example.com/oauth/authorize`
with the Consumer Key `0685bd91`. 

    https://sp.example.com/oauth/authorize?oauth_consumer_key=0685bd91 

##### Service Provider Obtains User Consent 

Once the User has been authenticated by the Service Provider, the Service
Provider MUST present the User with the option to grant access to the Consumer.
The Service Provider SHOULD specify to the User which Protected Resources the
Consumer is requesting, for how long the Consumer will have access to the
Protected Resources, and other important information about the authorization that will be
granted to the Consumer. If the User grants permission, the Service Provider
SHOULD retain information about the transaction, including the Token,
associated User and Consumer data, the requested Protected Resources, time limits, etc. If the User denies the Consumer access, the Service Provider will not provide the
Protected Resources to the Consumer.

##### Service Provider Responds With Authorized Single-Use Token and Token Secret

Assuming permission is granted, the Service Provider will create a Single-Use
Token and Token Token Secret and deliver it to the Consumer via an HTTP
redirect.

###### Response

The response for a web-based Consumer includes the following
`application/x-www-form-urlencoded` GET parameters: 

* `oauth_token` - The Single-Use Token. 
* `oauth_secret` - The Token Secret. 
* `oauth_state` (if provided in request) - The unmodified content provided by
  the Consumer during the Request step.

###### Example 

In this example, the Service Provider has created a Single-Use Token
`c3e347b6a5001c16` and Token Secret `678dfge7dghek243` for the Consumer whose
Callback Endpoint URL is `https://consumer.example.com/validate`, so
the Service Provider will redirect the User to the following URL: 

    https://consumer.example.com/validate?oauth_token=c3e347b6a5001c16&oath_token_secret=678dfge7dghek243
 
#### Desktop Consumers 

Desktop Consumers MUST first obtain a Single-Use Token, since they aren't
able to provide a Callback URL to which the Service Provider redirects the
User. This is done by making a request to the appropriate Service Provider's
API Endpoint URL.
 
##### Request Single-Use Token 

To request a Single-Use Token, the Consumer constructs a request to the
Service Provider's API Endpoint URL. The request is signed as described in
"Signing an API Request". Because the Consumer does not yet have a Single-Use Token or
Token Secret, these fields are left empty.
 
If the request is properly signed (using the Consumer Secret) and accepted by the Service Provider,
the Service Provider returns a unauthorized Single-Use Token and a Token Secret in the body of the response as newline separated
name-value pairs, followed by any additional data the Service Provider wishes
to provide.
 
###### Example
 
In this example, the Consumer has a Consumer Key `1b20acc6` and a
Consumer Secret `427a5979d9df7722`. The Service Provider's API Endpoint URL
for requesting a Single-Use Token is
`http://sp.example.com/oauth/get_su_token`, and the request is using the
HTTP GET method. The nonce is `17907867114999140772853922434221488511` and
the timestamp of `1186953553`. Using SHA1 as the signing algorithm, the
signature is then `26287279e66f7f183af02653e823625871167d16`, and the request
is as follows:
 
    https://sp.example.com/oauth/get_su_token?oauth_consumer_key=1b20acc6&oauth_nonce=17907867114999140772853922434221488511&oauth_ts=1186953553&oauth_sigalg=sha1&oauth_sig=26287279e66f7f183af02653e823625871167d16
 
The Service Provider generates a Single-Use Token `37bb49b4` and a
corresponding secret `d0e46c19`, and returns the following as the body of the
response:
 
    token=37bb49b4
    secret=d0e46c19
 
##### Direct User to Service Provider 

To exchange a Single-Use Token for a Multi-Use Token and Token Secret, the Consumer
MUST obtain approval from the User by directing the User to the Service
Provider. The Consumer constructs an `application/x-www-form-urlencoded`
HTTP GET request to the Service Provider's Authorization Endpoint URL which
will be sent via the User's user-agent (i.e., web browser).

###### Request

This request contains the following parameters: 

* `oauth_consumer_key`
: The Consumer Key 
* `oauth_token`
: The Single-Use Token obtained in the previous step.
* `oauth_state` (OPTIONAL)
: An `application/x-www-form-urlencoded` string that will be passed through
  unmodified to the Consumer (this parameter SHOULD only be used in the case of
  stateless web-based Consumers) 
* any additional parameters, as defined by the Service Provider.

Once the request URL has been generated the Consumer directs the User to the
URL.
 
###### Example 

In this example, the Consumer is requesting a Single-Use Token and Token Secret from
the Service Provider's Authorization Endpoint URL
`https://sp.example.com/oauth/authorize` with the Consumer Key `0685bd91` and
Single-Use Token `37bb49b4`.

    https://sp.example.com/oauth/authorize?oauth_consumer_key=0685bd91&oauth_token=37bb49b4

##### Service Provider Obtains User Consent 

The Service Provider obtains User consent in the same manner and with the same
requirements as for web-based Consumers.
 
###### Response 

Assuming permission is granted, the Service Provider will instruct the User
to inform the Consumer that authorization has completed at the appropriate
prompt within the Consumer application.

##### Obtaining a Multi-Use Token

Once the Single-Use Token and Token Secret have been authorized, the Consumer can
exchange them for a Multi-Use Token and Token Secret.

###### Request

To request a Multi-Use Token, the Consumer makes an HTTP request to an endpoint
for token exchange as specified by the Service Provider's documentation. The Service
Provider documentation MUST specifies the HTTP verb (GET or POST) for this endpoint and it is RECOMMENDED that this be a POST request. The request MUST be signed
with the Single-Use Token and Token Secret per the signing instructions below.

###### Response

If the request is valid, the Service Provider SHALL respond with text like so: 

    token=37bb49b4
    secret=d0e46c19

Where the Token and Token Secret are encoded like `application/x-www-form-urlencoded`,
followed by Service Provider specific data, as defined by the Service Provider's
API documentation. The Multi-Use Token and Token Secret are stored by the Consumer to
use when signing future requests. 

If the request is not successful, the Service Provider MUST respond with a HTTP
401 Not Authorized, and MAY include some further details about why the request
wasn't authorized.

#### Signing an API Request 

All OAuth API requests MUST be signed by the Consumer and the signature verified
by the Service Provider. The following steps describe the signature process: 

##### OAuth Request Parameters

All are REQUIRED except where stated.
 
* `oauth_consumer_key`
: A Consumer Key. This is an arbitrary Consumer application specific identifier. 
* `oauth_secret`
: The Consumer Secret that corresponds to the Consumer key. 
* `oauth_token`
: A Token. See the "Obtaining a Token" sections. 
* `oauth_token_secret`
: A  Token Secret. See the "Obtaining a Token" sections.
* `oauth_nonce`
: A one-time use value to verify the request has not been made before. See the
  "Generating Nonces" section. 
* `oauth_ts`
: An integer representing the time of request, expressed in number of
  seconds after January 1, 1970 00:00:00 GMT.
* `oauth_sigalg`
: The hashing algorithm that the Consumer used to sign the request. 
* `oauth_sig`
: The signature. 

##### Format of Request Parameters 

The request parameters MUST be concatenated in the following order:
 
    oauth_secret, oauth_consumer_key, oauth_token, oath_token_secret,
    http_request_method, http_request_uri, normalized_request_parameters,
    oauth_nonce, oauth_ts 

After the Consumer has normalized the request parameters (see below), the
following signing algorithm SHALL be used to generate the value of the
`oauth_sig`: 

1. generate an oauth_nonce (see Generating Nonces) 

2. normalize OAuth Request Parameters
   1. Escape the request parameter values using the percent-encoding (%xx) mechanism described in RFC3986.
   2. Concatenate the parameters resulting in name-value pairs separated by the
      ASCII '=' symbol.
      e.g., "oauth_secret=elephant" and "oauth_consumer_key=foo"

3. Concatenate the resulting name-value pairs into one string separated by the ASCII '&'
   symbol in the following order: 

    oauth_secret, oauth_consumer_key, oauth_token, http_request_method,
    http_request_uri, normalized_request_parameters, oauth_nonce, oauth_ts

4. sign or hash the concatenated string according to the chosen value of oauth_sigalg: 

    oauth_sig = md5(concatenated_string) 

    oauth_sig = sha1(concatenated_string) 

    oauth_sig = hmac_sha256(oauth_secret, concatenated_string)

    oauth_sig = openssl_x509_sign(private_certificate, concatenated_string)
    (in the case of using x509 certs, the Service Provider would have the
    Consumer's public key and therefore would provide an empty string as
    the secret)

##### Example

1. Fetch the 3rd page of friends updates from Twitter for user 123456
2. The basic API request looks like so:

      http://twitter.com/statuses/with_friends/123456.json?page=3&count=50

3. Assuming the use of the SHA1 signature method and the following values:
	* oauth_secret => 3a2cd35
	* oauth_consumer_key => 0685bd91
	* oauth_token => 540ad18
	* oauth_token_secret => x2s55k0
	* oauth_nonce => MTgzNTYxODk4Mw
	* oauth_ts => 1185517832

       oauth_sig = SHA1("oauth_secret=3a2cd35&oauth_consumer_key=0685bd91&oauth_token=540ad18&oauth_token_secret=x2s55k0&http_request_method=GET&http_request_uri=http%3A%2F%2Ftwitter.com%2Fstatuses%2Ffriends/123456.json&normalized_request_parameters=count%3D50%26page%3D3&oauth_nonce=MTgzNTYxODk4Mw&oauth_ts=1185517832")

4. We need to pass to the server (in cleartext) the Consumer Key (`oauth_consumer_key`),
   the Token (`oauth_token`), the timestamp (`oauth_ts`), the nonce
   (`oauth_nonce`), the signing algorithm (oauth_sigalg), and the signed
   request (`oauth_sig`).
   Consumers MUST NOT send any of the secrets with the request, since doing so
   would compromise the entire request, as well as subsequent requests.
5. The full signed request is then:

    GET http://twitter.com/statuses/friends/123456.json?page=3&count=50&oauth_key=0685bd91&oauth_token=540ad18&oauth_nonce=MTgzNTYxODk4Mw&oauth_ts=1181537927&oauth_sigalg=sha1&oauth_sig=2d047740b53ae16f670750bef5bb5c2a0f398f30

### Normalizing Request Parameters

The Consumer MUST first normalize request parameters by following the steps
below. OAuth Request Parameters (see above) MUST NOT be included in this
process. The normalized string MUST then be used when generating the signature
for a request.

1. Escape the request parameter names and values using the percent-encoding
   (%xx) mechanism described in RFC3986.
1. Sort the request parameters alphabetically by parameter name. If two or
   more parameters share the same name, then sort those parameters by their
   values.
   e.g., "count=50", "page=3"
   e.g., "count=3", "count=50", "page=3"
2. Concatenate the parameters resulting in name-value pairs separated by the
   ASCII '=' symbol.
   e.g., "count=50" and "page=3"
3. Concatenate the name-value pairs into one string separated by the ASCII '&'
   symbol.
   e.g., count=50&page=3

The encoding and format of the parameter names and their values MUST NOT be changed
during this process.  The Service Provider will perform this same set of steps
when verifying the signature.

### Generating Nonces

A nonce is a random string, uniquely generated for each request. The nonce
allows the Service Provider to verify that this request has never been made
before and helps prevent against replay attacks. More information about nonces
can be found on Wikipedia (http://en.wikipedia.org/wiki/Cryptographic_nonce).

### Using HTTP-Authorization Headers

This section defines an RFC 2617 extension to support OAuth.  It uses the standard Authorization and WWW-Authenticate headers to pass credentials rather than using URL parameters.  All Consumers SHOULD be able to supply an OAuth Authorization header as an alternative to passing URL parameters.  It is RECOMMENDED that Service Providers accept such a header and such Service Providers MUST signal Consumers by returning the OAuth WWW-Authenticate header upon all requests for the Protected Resource.  For the remainder of this section, we assume that the Service Provider under discussion has chosen to support this extension.

When using a HTTP-Authorization header, the OAuth Request Parameters are not included in the body of the request.  Rather they are included as the value of the header.

    Authorization: OAuth oauth_token="540ad18" oauth_key="0685bd91" oauth_nonce="MTgzNTYxODk4Mw" oauth_ts="1185517832" oauth_sigalg="SHA1" oauth_sig="2d047740b53ae16f670750bef5bb5c2a0f398f30"

To reject a request that lacks appropriate credentials, the Service Provider MUST respond with a 401 Unauthorized response.  Such a response MUST include at least one OAuth WWW-Authenticate header and MAY include additional WWW-Authenticate headers:

    401 Unauthorized
    ...
    WWW-Authenticate: OAuth

A Consumer MAY also include an empty, token-less OAuth Authorization header on any HTTP request to inform a Service Provider that it supports OAuth.  The Service Provider MUST then respond with the appropriate WWW-Authenticate header for the requested resource in the response.  For example, a Consumer could inquire using HEAD and then adjust its UI if the Service Provider supports OAuth.

### Implementation Suggestions

Timestamps SHOULD be good for 5 minutes, this gives sufficient time to deal
with network latency, without becoming a security hole, or placing an
unbearable burden on the server for tracking and storing nonces. Ideally
servers would provide a method for retrieving what they think the current time
is.

    Proposed UI for User authentication with the Service Provider? Too many protocols just leave user authentication interaction as a hand-wavy
    step. It would be great to at least provide best practices and/or sample
    mock-ups. - Rich Conlan, 08/14/07 8:27 AM 

## Error Messages

* HTTP 400 Bad Request
  * Invalid Timestamp
  * Unsupported Signing Algorithm
* HTTP 401 Unauthorized
  * Invalid Consumer Key
  * Invalid Token
  * Invalid Signature
  * Nonce Spent

## Security Considerations

* Credentials as GET params can get logged in various places

## Open Questions

* HTTP Headers
  * Not mandated, but having a standard for including OAuth in the
    HTTP_AUTHORIZATION header would be nice.
